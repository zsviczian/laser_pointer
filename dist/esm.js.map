{"mappings":"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","sources":["src/index.ts","src/state.ts","src/math.ts","src/simplify.ts"],"sourcesContent":["export * from './state'\nexport type { Point } from './math'\n","import type { Point } from './math'\nimport * as m from './math'\nimport { douglasPeucker } from './simplify'\n\nexport type SizeMappingDetails = {\n  pressure: number\n  runningLength: number\n  currentIndex: number\n  totalLength: number\n}\n\nexport type LaserPointerOptions = {\n  size: number\n\n  streamline: number\n  simplify: number\n  simplifyPhase: 'tail' | 'output' | 'input'\n\n  keepHead: boolean\n\n  sizeMapping: (details: SizeMappingDetails) => number\n}\n\nexport class LaserPointer {\n  static defaults: LaserPointerOptions = {\n    size: 2,\n    streamline: 0.45,\n    simplify: 0.1,\n    simplifyPhase: 'output',\n    keepHead: false,\n\n    sizeMapping: () => 1,\n  }\n\n  static constants = {\n    cornerDetectionMaxAngle: 75,\n    cornerDetectionVariance: (s: number) => (s > 35 ? 0.5 : 1),\n    maxTailLength: 50,\n  }\n\n  options: LaserPointerOptions\n  constructor(options: Partial<LaserPointerOptions>) {\n    this.options = Object.assign({}, LaserPointer.defaults, options)\n  }\n\n  originalPoints: Point[] = []\n\n  private stablePoints: Point[] = []\n  private tailPoints: Point[] = []\n\n  private isFresh = true\n\n  private get lastPoint(): Point {\n    return this.tailPoints[this.tailPoints.length - 1] ?? this.stablePoints[this.stablePoints.length - 1]\n  }\n\n  addPoint(point: Point) {\n    const lastPoint = this.originalPoints[this.originalPoints.length - 1]\n\n    if (lastPoint && lastPoint[0] === point[0] && lastPoint[1] === point[1]) {\n      return\n    }\n\n    this.originalPoints.push(point)\n\n    if (this.isFresh) {\n      this.isFresh = false\n      this.stablePoints.push(point)\n      return\n    }\n\n    if (this.options.streamline > 0) {\n      point = m.plerp(this.lastPoint, point, 1 - this.options.streamline)\n    }\n\n    this.tailPoints.push(point)\n\n    if (m.runLength(this.tailPoints) > LaserPointer.constants.maxTailLength) {\n      this.stabilizeTail()\n    }\n  }\n\n  close() {\n    this.stabilizeTail()\n  }\n\n  stabilizeTail() {\n    if (this.options.simplify > 0 && this.options.simplifyPhase == 'tail') {\n      throw new Error('Not implemented yet')\n    } else {\n      this.stablePoints.push(...this.tailPoints)\n      this.tailPoints = []\n    }\n  }\n\n  private getSize(\n    sizeOverride: number | undefined,\n    pressure: number,\n    index: number,\n    totalLength: number,\n    runningLength: number\n  ) {\n    return (\n      (sizeOverride ?? this.options.size) *\n      this.options.sizeMapping({\n        pressure: pressure,\n        runningLength: runningLength,\n        currentIndex: index,\n        totalLength: totalLength,\n      })\n    )\n  }\n\n  getStrokeOutline(sizeOverride?: number | undefined): Point[] {\n    if (this.isFresh) {\n      return []\n    }\n\n    let points = [...this.stablePoints, ...this.tailPoints]\n\n    if (this.options.simplify > 0 && this.options.simplifyPhase === 'input') {\n      points = douglasPeucker(points, this.options.simplify)\n    }\n\n    const len = points.length\n\n    if (len === 0) {\n      return []\n    }\n\n    if (len === 1) {\n      const c = points[0]\n\n      const size = this.getSize(sizeOverride, c[2], 0, len, 0)\n\n      if (size < 0.5) {\n        return []\n      }\n\n      const ps: Point[] = []\n\n      for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16) {\n        ps.push(m.add(c, m.smul(m.rot([1, 0, 0] as Point, theta), size)))\n      }\n\n      ps.push(m.add(c, m.smul([1, 0, 0] as Point, this.getSize(sizeOverride, c[2], 0, len, 0))))\n\n      return ps\n    }\n\n    if (len === 2) {\n      const c = points[0]\n      const n = points[1]\n\n      const cSize = this.getSize(sizeOverride, c[2], 0, len, 0)\n      const nSize = this.getSize(sizeOverride, n[2], 0, len, 0)\n\n      if (cSize < 0.5 || nSize < 0.5) {\n        return []\n      }\n\n      const ps: Point[] = []\n\n      const pAngle = m.angle(c, [c[0], c[1] - 100, c[2]] as Point, n)\n\n      for (let theta = pAngle; theta <= Math.PI + pAngle; theta += Math.PI / 16) {\n        ps.push(m.add(c, m.smul(m.rot([1, 0, 0] as Point, theta), cSize)))\n      }\n\n      for (let theta = Math.PI + pAngle; theta <= Math.PI * 2 + pAngle; theta += Math.PI / 16) {\n        ps.push(m.add(n, m.smul(m.rot([1, 0, 0] as Point, theta), nSize)))\n      }\n\n      ps.push(ps[0])\n\n      return ps\n    }\n\n    const forwardPoints: Point[] = []\n    const backwardPoints: Point[] = []\n\n    let speed = 0\n    let prevSpeed = 0\n\n    let visibleStartIndex = 0\n    let runningLength = 0\n\n    for (let i = 1; i < len - 1; i++) {\n      const p = points[i - 1],\n        c = points[i],\n        n = points[i + 1]\n\n      let pressure = c[2]\n\n      const d = m.dist(p, c)\n      runningLength += d\n      speed = prevSpeed + (d - prevSpeed) * 0.2\n\n      const cSize = this.getSize(sizeOverride, pressure, i, len, runningLength)\n\n      if (cSize === 0) {\n        visibleStartIndex = i + 1\n        continue\n      }\n\n      const dirPC = m.norm(m.sub(p, c))\n      const dirNC = m.norm(m.sub(n, c))\n      const p1dirPC = m.rot(dirPC, Math.PI / 2)\n      const p2dirPC = m.rot(dirPC, -Math.PI / 2)\n      const p1dirNC = m.rot(dirNC, Math.PI / 2)\n      const p2dirNC = m.rot(dirNC, -Math.PI / 2)\n\n      const p1PC = m.add(c, m.smul(p1dirPC, cSize))\n      const p2PC = m.add(c, m.smul(p2dirPC, cSize))\n      const p1NC = m.add(c, m.smul(p1dirNC, cSize))\n      const p2NC = m.add(c, m.smul(p2dirNC, cSize))\n\n      const ftdir = m.add(p1dirPC, p2dirNC)\n      const btdir = m.add(p2dirPC, p1dirNC)\n\n      const paPC = m.add(c, m.smul(m.mag(ftdir) === 0 ? dirPC : m.norm(ftdir), cSize))\n      const paNC = m.add(c, m.smul(m.mag(btdir) === 0 ? dirNC : m.norm(btdir), cSize))\n\n      const cAngle = m.normAngle(m.angle(c, p, n))\n      const D_ANGLE =\n        (LaserPointer.constants.cornerDetectionMaxAngle / 180) *\n        Math.PI *\n        LaserPointer.constants.cornerDetectionVariance(speed)\n\n      if (Math.abs(cAngle) < D_ANGLE) {\n        const tAngle = Math.abs(m.normAngle(Math.PI - cAngle)) // turn angle\n\n        if (tAngle === 0) {\n          continue\n        }\n\n        if (cAngle < 0) {\n          backwardPoints.push(p2PC, paNC)\n\n          for (let theta = 0; theta <= tAngle; theta += tAngle / 4) {\n            forwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, cSize), theta)))\n          }\n\n          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4) {\n            backwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, cSize), theta)))\n          }\n\n          backwardPoints.push(paNC, p1NC)\n        } else {\n          forwardPoints.push(p1PC, paPC)\n\n          for (let theta = 0; theta <= tAngle; theta += tAngle / 4) {\n            backwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, -cSize), -theta)))\n          }\n\n          for (let theta = tAngle; theta >= 0; theta -= tAngle / 4) {\n            forwardPoints.push(m.add(c, m.rot(m.smul(p1dirPC, -cSize), -theta)))\n          }\n          forwardPoints.push(paPC, p2NC)\n        }\n      } else {\n        forwardPoints.push(paPC)\n        backwardPoints.push(paNC)\n      }\n\n      prevSpeed = speed\n    }\n\n    if (visibleStartIndex >= len - 2) {\n      if (this.options.keepHead) {\n        const c = points[len - 1]\n\n        const ps: Point[] = []\n\n        for (let theta = 0; theta <= Math.PI * 2; theta += Math.PI / 16) {\n          ps.push(m.add(c, m.smul(m.rot([1, 0, 0] as Point, theta), this.options.size)))\n        }\n\n        ps.push(m.add(c, m.smul([1, 0, 0] as Point, this.options.size)))\n\n        return ps\n      } else {\n        return []\n      }\n    }\n\n    const first = points[visibleStartIndex]\n    const second = points[visibleStartIndex + 1]\n    const penultimate = points[len - 2]\n    const ultimate = points[len - 1]\n\n    const dirFS = m.norm(m.sub(second, first))\n    const dirPU = m.norm(m.sub(penultimate, ultimate))\n\n    const ppdirFS = m.rot(dirFS, -Math.PI / 2)\n    const ppdirPU = m.rot(dirPU, Math.PI / 2)\n\n    const startCapSize = this.getSize(sizeOverride, first[2], 0, len, 0)\n    const startCap: Point[] = []\n\n    const endCapSize = this.options.keepHead\n      ? this.options.size\n      : this.getSize(sizeOverride, penultimate[2], len - 2, len, runningLength)\n\n    const endCap: Point[] = []\n\n    if (startCapSize > 1) {\n      for (let theta = 0; theta <= Math.PI; theta += Math.PI / 16) {\n        startCap.unshift(m.add(first, m.rot(m.smul(ppdirFS, startCapSize), -theta)))\n      }\n\n      startCap.unshift(m.add(first, m.smul(ppdirFS, -startCapSize)))\n    } else {\n      startCap.push(first)\n    }\n\n    for (let theta = 0; theta <= Math.PI * 3; theta += Math.PI / 16) {\n      endCap.push(m.add(ultimate, m.rot(m.smul(ppdirPU, -endCapSize), -theta)))\n    }\n\n    const strokeOutline = [...startCap, ...forwardPoints, ...endCap.reverse(), ...backwardPoints.reverse()]\n\n    if (startCap.length > 0) {\n      strokeOutline.push(startCap[0])\n    }\n\n    if (this.options.simplify > 0 && this.options.simplifyPhase === 'output') {\n      return douglasPeucker(strokeOutline, this.options.simplify)\n    }\n\n    return strokeOutline\n  }\n}\n","export type Point = [x: number, y: number, r: number]\n\nexport function add([ax, ay, ar]: Point, [bx, by, br]: Point): Point {\n  return [ax + bx, ay + by, ar + br]\n}\n\nexport function sub([ax, ay, ar]: Point, [bx, by, br]: Point): Point {\n  return [ax - bx, ay - by, ar - br]\n}\n\nexport function smul([x, y, r]: Point, s: number): Point {\n  return [x * s, y * s, r * s]\n}\n\nexport function norm([x, y, r]: Point): Point {\n  return [x / Math.sqrt(x ** 2 + y ** 2), y / Math.sqrt(x ** 2 + y ** 2), r]\n}\n\nexport function rot([x, y, r]: Point, rad: number): Point {\n  return [Math.cos(rad) * x - Math.sin(rad) * y, Math.sin(rad) * x + Math.cos(rad) * y, r]\n}\n\nexport function plerp(a: Point, b: Point, t: number): Point {\n  return add(a, smul(sub(b, a), t))\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n  return a + (b - a) * t\n}\n\nexport function angle(p: Point, p1: Point, p2: Point) {\n  return Math.atan2(p2[1] - p[1], p2[0] - p[0]) - Math.atan2(p1[1] - p[1], p1[0] - p[0])\n}\n\nexport function normAngle(a: number) {\n  return Math.atan2(Math.sin(a), Math.cos(a))\n}\n\nexport function mag([x, y]: Point) {\n  return Math.sqrt(x ** 2 + y ** 2)\n}\n\nexport function dist([ax, ay]: Point, [bx, by]: Point): number {\n  return Math.sqrt((bx - ax) ** 2 + (by - ay) ** 2)\n}\n\nexport function getCircleAndPerpendicularLineIntersectionsAtPoint(\n  point: Point,\n  direction: Point,\n  radius: number\n): [Point, Point] {\n  return [\n    add(point, smul(norm(rot(direction, Math.PI / 2)), radius)),\n    add(point, smul(norm(rot(direction, -Math.PI / 2)), radius)),\n  ]\n}\n\nexport function runLength(ps: Point[]): number {\n  if (ps.length < 2) return 0\n\n  let len = 0\n\n  for (let i = 1; i <= ps.length - 1; i++) {\n    len += dist(ps[i - 1], ps[i])\n  }\n\n  len += dist(ps[ps.length -2], ps[ps.length - 1])\n\n  return len\n}\n\nexport const clamp = (v: number, min: number, max: number) => Math.max(min, Math.min(max, v))\n\nexport function distancePointToSegment(p3: Point, p1: Point, p2: Point) {\n  const sMag = dist(p1, p2)\n\n  if (sMag === 0) return dist(p3, p1)\n\n  const u = clamp(((p3[0] - p1[0]) * (p2[0] - p1[0]) + (p3[1] - p1[1]) * (p2[1] - p1[1])) / sMag ** 2, 0, 1)\n\n  const pi: Point = [p1[0] + u * (p2[0] - p1[0]), p1[1] + u * (p2[1] - p1[1]), p3[2]]\n\n  return dist(pi, p3)\n}\n","import { Point, distancePointToSegment } from './math'\n\nexport function douglasPeucker(points: Point[], epsilon: number): Point[] {\n  if (epsilon === 0) {\n    return points\n  }\n\n  if (points.length <= 2) {\n    return points\n  }\n\n  const first = points[0]\n  const last = points[points.length - 1]\n\n  const [maxDistance, maxIndex] = points.reduce(\n    ([maxDistance, maxIndex], point, index) => {\n      const distance = distancePointToSegment(point, first, last)\n\n      return distance > maxDistance ? [distance, index] : [maxDistance, maxIndex]\n    },\n    [0, -1]\n  )\n\n  if (maxDistance >= epsilon) {\n    const maxIndexPoint = points[maxIndex]\n\n    return [\n      ...douglasPeucker([first, ...points.slice(1, maxIndex), maxIndexPoint], epsilon).slice(0, -1),\n      maxIndexPoint,\n      ...douglasPeucker([maxIndexPoint, ...points.slice(maxIndex, -1), last], epsilon).slice(1),\n    ]\n  } else {\n    return [first, last]\n  }\n}\n"],"names":["Point","m","douglasPeucker","SizeMappingDetails","pressure","runningLength","currentIndex","totalLength","LaserPointerOptions","size","streamline","simplify","simplifyPhase","keepHead","sizeMapping","details","LaserPointer","constructor","options","Partial","_defineProperty","Object","assign","defaults","lastPoint","tailPoints","length","stablePoints","addPoint","point","originalPoints","push","isFresh","plerp","runLength","constants","maxTailLength","stabilizeTail","close","Error","getSize","sizeOverride","index","getStrokeOutline","points","len","c","ps","theta","Math","PI","add","smul","rot","n","cSize","nSize","pAngle","angle","forwardPoints","backwardPoints","speed","prevSpeed","visibleStartIndex","i","p","d","dist","dirPC","norm","sub","dirNC","p1dirPC","p2dirPC","p1dirNC","p2dirNC","p1PC","p2PC","p1NC","p2NC","ftdir","btdir","paPC","mag","paNC","cAngle","normAngle","D_ANGLE","cornerDetectionMaxAngle","cornerDetectionVariance","abs","tAngle","first","second","penultimate","ultimate","dirFS","dirPU","ppdirFS","ppdirPU","startCapSize","startCap","endCapSize","endCap","unshift","strokeOutline","reverse","s","x","y","r","ax","ay","ar","bx","by","br","sqrt","rad","cos","sin","a","b","t","lerp","p1","p2","atan2","getCircleAndPerpendicularLineIntersectionsAtPoint","direction","radius","clamp","v","min","max","distancePointToSegment","p3","sMag","u","pi","epsilon","last","maxDistance","maxIndex","reduce","distance","maxIndexPoint","slice"],"version":3,"file":"esm.js.map"}